[TOC]
# 基于PID的四旋翼无人机轨迹跟踪控制

## 二维笔记说明

### 一、展示二维平面四旋翼圆形轨迹跟踪（以其为例）

---

### 二、状态方程解读

#### 状态方程体系

$$
\begin{aligned}
\dot{y} &= v_y \\
\dot{z} &= v_z \\
\dot{ϕ} &= \omega \\
\dot{v_y} &= \frac{F \sin \phi}{m} \\
\dot{v_z} &= \frac{F \cos \phi}{m} - g \\
\dot{ \omega} &= -\frac{1}{J} M \\
\end{aligned}
$$

1. **位置与速度关系**  
   - 物理意义：y方向位置变化率等于y方向速度  
   - 动力学层级：运动学方程  

2. **垂直方向位置与速度**  
   - 物理意义：z方向位置变化率等于z方向速度  
   - 动力学层级：运动学方程  

3. **俯仰角与角速度**  
   - 物理意义：俯仰角变化率等于角速度  
   - 动力学层级：运动学方程  

4. **y方向加速度**  
   - 物理意义：由推力的水平分量产生  
   - 关键参数：  
     - \( F \)：旋翼总推力  
     - \( ϕ \)：俯仰角  

5. **z方向加速度**  
   - 物理意义：由推力的垂直分量减去重力加速度  
   - 关键参数： \( g \)：重力加速度  (向下作用)
    

6. **角加速度与力矩**  
   - 物理意义：角加速度由力矩驱动，负号表⽰⼒矩⽅向与旋转⽅向定义相反
   - 关键参数：  
     - \( M \)：力矩  
     - \( J \)：转动惯量  

---

### 三、轨迹生成

#### 1. 正弦信号源模块
- **模块1**：\( 5 \times \sin(u) \)  
  - 功能：生成振幅为5的正弦波信号，输出至端口\( Y \)。
- **模块2**：\( 5 \times \sin(0.5u) \)  
  - 功能：生成频率减半的正弦波，输出至端口\( Z \)。

#### 2. 输出端口
- 使用`Scope`模块观测波形，输出至工作空间。

---

### 四、PID控制器与二维四旋翼动态系统

#### 1. 二维四旋翼动态系统
- **整体架构**  
  - 模型名称：`quadrotor2_circle/二维四旋翼动态系统`  
  - 核心模块：  
    - `quadrotor2_system`：定义物理参数（质量\( m \)、转动惯量\( J \)），通过动力学方程计算状态变量。  
    - `state`：存储位置\( (y, z) \)和姿态\( \phi \)，形成闭环反馈。  

- **技术含义**  
  - 状态反馈：实时数据驱动闭环控制。  

#### 2. PID控制器设计
- **整体架构**  
  - 双闭环控制：外环（位置误差）和内环（姿态响应）。  
  - 核心模块：  
    - PID模块：处理高度和横向位置误差。  
    - 限幅模块：约束输出\( F \)和\( M \)。  

- **抗饱和设计**  
  - 防止控制量超出电机能力范围。  

#### 3. 协同工作原理
- **信号闭环流程**  
  1. 测量状态 → 2. 计算误差 → 3. 生成控制信号 → 4. 动态系统响应 → 5. 更新状态。  

---

### 五、绘制二维四旋翼视觉跟踪代码实现

#### S代码解析
```matlab
function draw_quadrotor_2D(t, position, angle, traj)
%% 定义函数参数
% 输入参数:
%   t: 时间序列 [n×1]
%   position: 二维位置坐标 [n×2]
%   angle: 滚转角 [n×1]
%   traj: 参考轨迹坐标 [n×2]

%% 初始化图形窗口
fig = figure('Name', 'Quadrotor_2D', 'Position', [500 250 400 300]);
ax = axes;
axis equal;

%% 绘制参考轨迹
if nargin > 3
    plot(ax, traj(:,1), traj(:,2), '-k', 'LineWidth', 2);
end

%% 动态更新四旋翼姿态
for i = 1:size(t)
    quadrotor_pos = position(i,:)';
    phi = angle(i);
    
    % 旋转矩阵
    R = [cos(phi) sin(phi); -sin(phi) cos(phi)];
    wHb = [R quadrotor_pos; 0 0 1]; % 齐次变换矩阵
    
    % 更新图形对象
    set(h1, 'XData', quadrotor_atti(1,[1 2]), 'YData', quadrotor_atti(2,[1 2]));
    drawnow;
end
end
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgwMDMxMDM1MV19
-->